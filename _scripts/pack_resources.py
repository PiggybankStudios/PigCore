#!/usr/bin/python

#  File:   pack_resources.py
#  Author: Taylor Robbins
#  Date:   03\01\2025
#  Description: 
#  	** Takes the contents of a folder, zips them into a .zip archive, converts the
#   ** binary contents of the zip file into a C u8 array and writes it into a .c file,
#   ** writes a header file that declares the array that can be #included
#  Usage:
#  	** python pack_resources.py [resources_folder] [output_zip_path] [output_h_path] [output_c_path]

import sys, shutil, os;

def plural(count):
#
	if (count == 1): return "";
	else: return "s";
#
def formatBytes(numBytes):
#
	if (numBytes > 1024):
	#
		if (numBytes > 1024*1024):
		#
			if (numBytes > 1024*1024*1024):
			#
				return "%dGB %dMB %dkB %dB" % (numBytes / (1024*1024*1024), (numBytes % (1024*1024*1024)) / (1024*1024), (numBytes % (1024*1024)) / 1024, numBytes % 1024);
			#
			else:
			#
				return "%dMB %dkB %dB" % (numBytes / (1024*1024), (numBytes % (1024*1024)) / 1024, numBytes % 1024);
			#
		#
		else:
		#
			return "%dkB %dB" % (numBytes / 1024, numBytes % 1024);
		#
	#
	else:
	#
		return "%dB" % (numBytes);
	#
#

numArguments = len(sys.argv);
arguments = sys.argv;

# First argument is always the path to the python file
if (numArguments > 1):
#
	numArguments -= 1;
	arguments = arguments[1:];
#

if (numArguments != 4):
#
	print("pack_resources.py expects exactly 4 arguments, not %d" % numArguments);
	print("Usage python pack_resources.py [resources_folder] [output_zip_path] [output_h_path] [output_c_path]");
	exit();
#

resourcesFolderPath = arguments[0];
outputZipPath = arguments[1];
outputHeaderPath = arguments[2];
outputSourcePath = arguments[3];
outputZipPathNoExt = outputZipPath;
if (outputZipPath.endswith(".zip")): outputZipPathNoExt = outputZipPath[:-4];
else: print("Warning output zip path does not end with \".zip\", the file created by shutil.make_archive will not exactly match your desired file name!");

print("[Zipping %s...]" % resourcesFolderPath);
shutil.make_archive(outputZipPathNoExt, "zip", resourcesFolderPath);

arraySize = 0;
with open(outputZipPath, "rb") as zipFile:
#
	zipContents = zipFile.read();
	arraySize = len(zipContents);
	print("[%s is %s]" % (outputZipPath, formatBytes(arraySize)));
	# print("zipContents is %s" % type(zipContents));
	with open(outputSourcePath, "w") as outputFile:
	#
		outputFile.write("// This file is generated by pack_resources.py! Any hand edits will be lost!\n\n");
		outputFile.write("u8 resources_zip_bytes[%d] = {\n" % arraySize);
		lineLength = 0;
		lineIndex = 0;
		byteIndex = 0;
		for byte in zipContents:
		#
			if (lineLength >= 256):
			#
				outputFile.write("\n");
				lineLength = 0;
				lineIndex += 1;
				if ((lineIndex % 64) == 0): outputFile.write("\n");
			#
			if (lineLength == 0): outputFile.write("\t");
			outputFile.write("0x%02X" % byte);
			if (byteIndex+1 < len(zipContents)): outputFile.write(", ");
			lineLength += 1;
			byteIndex += 1;
		#
		outputFile.write("\n};\n\n");
	#
#
print("[%s is %s]" % (outputSourcePath, formatBytes(os.path.getsize(outputSourcePath))));

with open(outputHeaderPath, "w") as headerFile:
#
	headerGuardName = "_" + os.path.basename(outputHeaderPath).upper().replace(".", "_");
	headerFile.write("/*\n");
	headerFile.write("File:   %s\n" % os.path.basename(outputHeaderPath));
	headerFile.write("Author: WARNING: This file is generated by pack_resources.py! Any hand edits will be lost!\n");
	headerFile.write("*/\n\n");
	headerFile.write("#ifndef %s\n#define %s\n\n" % (headerGuardName, headerGuardName));
	headerFile.write("extern u8 resources_zip_bytes[%d];\n\n" % arraySize);
	headerFile.write("#endif //%s\n\n" % headerGuardName);
#
print("[%s Written!]" % outputHeaderPath);
