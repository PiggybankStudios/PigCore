/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: parse_proto_google_types.proto */

#ifndef PROTOBUF_C_parse_5fproto_5fgoogle_5ftypes_2eproto__INCLUDED
#define PROTOBUF_C_parse_5fproto_5fgoogle_5ftypes_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protobuf-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1005002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protobuf-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protobuf-c.
#endif


typedef struct ProtoDuration ProtoDuration;
typedef struct ProtoTimestamp ProtoTimestamp;
typedef struct ProtoInterval ProtoInterval;
typedef struct ProtoDate ProtoDate;
typedef struct ProtoTimeOfDay ProtoTimeOfDay;
typedef struct ProtoFieldMask ProtoFieldMask;
typedef struct ProtoPostalAddress ProtoPostalAddress;
typedef struct ProtoMoney ProtoMoney;
typedef struct ProtoLatLng ProtoLatLng;
typedef struct ProtoColor ProtoColor;


/* --- enums --- */

typedef enum _Month {
  MONTH__MONTH_UNSPECIFIED = 0,
  MONTH__JANUARY = 1,
  MONTH__FEBRUARY = 2,
  MONTH__MARCH = 3,
  MONTH__APRIL = 4,
  MONTH__MAY = 5,
  MONTH__JUNE = 6,
  MONTH__JULY = 7,
  MONTH__AUGUST = 8,
  MONTH__SEPTEMBER = 9,
  MONTH__OCTOBER = 10,
  MONTH__NOVEMBER = 11,
  MONTH__DECEMBER = 12
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(MONTH)
} Month;
typedef enum _DayOfWeek {
  DAY_OF_WEEK__DAY_OF_WEEK_UNSPECIFIED = 0,
  DAY_OF_WEEK__MONDAY = 1,
  DAY_OF_WEEK__TUESDAY = 2,
  DAY_OF_WEEK__WEDNESDAY = 3,
  DAY_OF_WEEK__THURSDAY = 4,
  DAY_OF_WEEK__FRIDAY = 5,
  DAY_OF_WEEK__SATURDAY = 6,
  DAY_OF_WEEK__SUNDAY = 7
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DAY_OF_WEEK)
} DayOfWeek;

/* --- messages --- */

/*
 * See https://protobuf.dev/best-practices/dos-donts/#well-known-common
 */
struct  ProtoDuration
{
  ProtobufCMessage base;
  /*
   * Signed seconds of the span of time. Must be from -315,576,000,000
   * to +315,576,000,000 inclusive. Note: these bounds are computed from:
   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
   */
  int64_t seconds;
  /*
   * Signed fractions of a second at nanosecond resolution of the span
   * of time. Durations less than one second are represented with a 0
   * `seconds` field and a positive or negative `nanos` field. For durations
   * of one second or more, a non-zero value for the `nanos` field must be
   * of the same sign as the `seconds` field. Must be from -999,999,999
   * to +999,999,999 inclusive.
   */
  int32_t nanos;
};
#define PROTO_DURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_duration__descriptor) \
    , 0, 0 }


struct  ProtoTimestamp
{
  ProtobufCMessage base;
  /*
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  int64_t seconds;
  /*
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive.
   */
  int32_t nanos;
};
#define PROTO_TIMESTAMP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_timestamp__descriptor) \
    , 0, 0 }


struct  ProtoInterval
{
  ProtobufCMessage base;
  /*
   * Optional. Inclusive start of the interval.
   * If specified, a Timestamp matching this interval will have to be the same
   * or after the start.
   */
  ProtoTimestamp *start_time;
  /*
   * Optional. Exclusive end of the interval.
   * If specified, a Timestamp matching this interval will have to be before the
   * end.
   */
  ProtoTimestamp *end_time;
};
#define PROTO_INTERVAL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_interval__descriptor) \
    , NULL, NULL }


struct  ProtoDate
{
  ProtobufCMessage base;
  /*
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without
   * a year.
   */
  int32_t year;
  /*
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a
   * month and day.
   */
  int32_t month;
  /*
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
   * to specify a year by itself or a year and month where the day isn't
   * significant.
   */
  int32_t day;
};
#define PROTO_DATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_date__descriptor) \
    , 0, 0, 0 }


struct  ProtoTimeOfDay
{
  ProtobufCMessage base;
  /*
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
   * to allow the value "24:00:00" for scenarios like business closing time.
   */
  int32_t hours;
  /*
   * Minutes of hour of day. Must be from 0 to 59.
   */
  int32_t minutes;
  /*
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may
   * allow the value 60 if it allows leap-seconds.
   */
  int32_t seconds;
  /*
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   */
  int32_t nanos;
};
#define PROTO_TIME_OF_DAY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_time_of_day__descriptor) \
    , 0, 0, 0, 0 }


struct  ProtoFieldMask
{
  ProtobufCMessage base;
  /*
   * The set of field mask paths.
   */
  size_t n_paths;
  char **paths;
};
#define PROTO_FIELD_MASK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_field_mask__descriptor) \
    , 0,NULL }


struct  ProtoPostalAddress
{
  ProtobufCMessage base;
  /*
   * The schema revision of the `PostalAddress`. This must be set to 0, which is
   * the latest revision.
   * All new revisions **must** be backward compatible with old revisions.
   */
  int32_t revision;
  /*
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   */
  char *region_code;
  /*
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   */
  char *language_code;
  /*
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   */
  char *postal_code;
  /*
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. CÃ´te d'Ivoire).
   */
  char *sorting_code;
  /*
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   */
  char *administrative_area;
  /*
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   */
  char *locality;
  /*
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   */
  char *sublocality;
  /*
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   */
  size_t n_address_lines;
  char **address_lines;
  /*
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   */
  size_t n_recipients;
  char **recipients;
  /*
   * Optional. The name of the organization at the address.
   */
  char *organization;
};
#define PROTO_POSTAL_ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_postal_address__descriptor) \
    , 0, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL, 0,NULL, (char *)protobuf_c_empty_string }


struct  ProtoMoney
{
  ProtobufCMessage base;
  /*
   * The three-letter currency code defined in ISO 4217.
   */
  char *currency_code;
  /*
   * The whole units of the amount.
   * For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
   */
  int64_t units;
  /*
   * Number of nano (10^-9) units of the amount.
   * The value must be between -999,999,999 and +999,999,999 inclusive.
   * If `units` is positive, `nanos` must be positive or zero.
   * If `units` is zero, `nanos` can be positive, zero, or negative.
   * If `units` is negative, `nanos` must be negative or zero.
   * For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
   */
  int32_t nanos;
};
#define PROTO_MONEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_money__descriptor) \
    , (char *)protobuf_c_empty_string, 0, 0 }


struct  ProtoLatLng
{
  ProtobufCMessage base;
  /*
   * The latitude in degrees. It must be in the range [-90.0, +90.0].
   */
  double latitude;
  /*
   * The longitude in degrees. It must be in the range [-180.0, +180.0].
   */
  double longitude;
};
#define PROTO_LAT_LNG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_lat_lng__descriptor) \
    , 0, 0 }


struct  ProtoColor
{
  ProtobufCMessage base;
  /*
   * The amount of red in the color as a value in the interval [0, 1].
   */
  float red;
  /*
   * The amount of green in the color as a value in the interval [0, 1].
   */
  float green;
  /*
   * The amount of blue in the color as a value in the interval [0, 1].
   */
  float blue;
  /*
   * The fraction of this color that should be applied to the pixel. That is,
   * the final pixel color is defined by the equation:
   *   `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)`
   * This means that a value of 1.0 corresponds to a solid color, whereas
   * a value of 0.0 corresponds to a completely transparent color. This
   * uses a wrapper message rather than a simple float scalar so that it is
   * possible to distinguish between a default value and the value being unset.
   * If omitted, this color object is rendered as a solid color
   * (as if the alpha value had been explicitly given a value of 1.0).
   */
  /*
   *NOTE: This used to use google.protobuf.FloatValue
   */
  float alpha;
};
#define PROTO_COLOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto_color__descriptor) \
    , 0, 0, 0, 0 }


/* ProtoDuration methods */
void   proto_duration__init
                     (ProtoDuration         *message);
size_t proto_duration__get_packed_size
                     (const ProtoDuration   *message);
size_t proto_duration__pack
                     (const ProtoDuration   *message,
                      uint8_t             *out);
size_t proto_duration__pack_to_buffer
                     (const ProtoDuration   *message,
                      ProtobufCBuffer     *buffer);
ProtoDuration *
       proto_duration__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_duration__free_unpacked
                     (ProtoDuration *message,
                      ProtobufCAllocator *allocator);
/* ProtoTimestamp methods */
void   proto_timestamp__init
                     (ProtoTimestamp         *message);
size_t proto_timestamp__get_packed_size
                     (const ProtoTimestamp   *message);
size_t proto_timestamp__pack
                     (const ProtoTimestamp   *message,
                      uint8_t             *out);
size_t proto_timestamp__pack_to_buffer
                     (const ProtoTimestamp   *message,
                      ProtobufCBuffer     *buffer);
ProtoTimestamp *
       proto_timestamp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_timestamp__free_unpacked
                     (ProtoTimestamp *message,
                      ProtobufCAllocator *allocator);
/* ProtoInterval methods */
void   proto_interval__init
                     (ProtoInterval         *message);
size_t proto_interval__get_packed_size
                     (const ProtoInterval   *message);
size_t proto_interval__pack
                     (const ProtoInterval   *message,
                      uint8_t             *out);
size_t proto_interval__pack_to_buffer
                     (const ProtoInterval   *message,
                      ProtobufCBuffer     *buffer);
ProtoInterval *
       proto_interval__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_interval__free_unpacked
                     (ProtoInterval *message,
                      ProtobufCAllocator *allocator);
/* ProtoDate methods */
void   proto_date__init
                     (ProtoDate         *message);
size_t proto_date__get_packed_size
                     (const ProtoDate   *message);
size_t proto_date__pack
                     (const ProtoDate   *message,
                      uint8_t             *out);
size_t proto_date__pack_to_buffer
                     (const ProtoDate   *message,
                      ProtobufCBuffer     *buffer);
ProtoDate *
       proto_date__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_date__free_unpacked
                     (ProtoDate *message,
                      ProtobufCAllocator *allocator);
/* ProtoTimeOfDay methods */
void   proto_time_of_day__init
                     (ProtoTimeOfDay         *message);
size_t proto_time_of_day__get_packed_size
                     (const ProtoTimeOfDay   *message);
size_t proto_time_of_day__pack
                     (const ProtoTimeOfDay   *message,
                      uint8_t             *out);
size_t proto_time_of_day__pack_to_buffer
                     (const ProtoTimeOfDay   *message,
                      ProtobufCBuffer     *buffer);
ProtoTimeOfDay *
       proto_time_of_day__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_time_of_day__free_unpacked
                     (ProtoTimeOfDay *message,
                      ProtobufCAllocator *allocator);
/* ProtoFieldMask methods */
void   proto_field_mask__init
                     (ProtoFieldMask         *message);
size_t proto_field_mask__get_packed_size
                     (const ProtoFieldMask   *message);
size_t proto_field_mask__pack
                     (const ProtoFieldMask   *message,
                      uint8_t             *out);
size_t proto_field_mask__pack_to_buffer
                     (const ProtoFieldMask   *message,
                      ProtobufCBuffer     *buffer);
ProtoFieldMask *
       proto_field_mask__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_field_mask__free_unpacked
                     (ProtoFieldMask *message,
                      ProtobufCAllocator *allocator);
/* ProtoPostalAddress methods */
void   proto_postal_address__init
                     (ProtoPostalAddress         *message);
size_t proto_postal_address__get_packed_size
                     (const ProtoPostalAddress   *message);
size_t proto_postal_address__pack
                     (const ProtoPostalAddress   *message,
                      uint8_t             *out);
size_t proto_postal_address__pack_to_buffer
                     (const ProtoPostalAddress   *message,
                      ProtobufCBuffer     *buffer);
ProtoPostalAddress *
       proto_postal_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_postal_address__free_unpacked
                     (ProtoPostalAddress *message,
                      ProtobufCAllocator *allocator);
/* ProtoMoney methods */
void   proto_money__init
                     (ProtoMoney         *message);
size_t proto_money__get_packed_size
                     (const ProtoMoney   *message);
size_t proto_money__pack
                     (const ProtoMoney   *message,
                      uint8_t             *out);
size_t proto_money__pack_to_buffer
                     (const ProtoMoney   *message,
                      ProtobufCBuffer     *buffer);
ProtoMoney *
       proto_money__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_money__free_unpacked
                     (ProtoMoney *message,
                      ProtobufCAllocator *allocator);
/* ProtoLatLng methods */
void   proto_lat_lng__init
                     (ProtoLatLng         *message);
size_t proto_lat_lng__get_packed_size
                     (const ProtoLatLng   *message);
size_t proto_lat_lng__pack
                     (const ProtoLatLng   *message,
                      uint8_t             *out);
size_t proto_lat_lng__pack_to_buffer
                     (const ProtoLatLng   *message,
                      ProtobufCBuffer     *buffer);
ProtoLatLng *
       proto_lat_lng__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_lat_lng__free_unpacked
                     (ProtoLatLng *message,
                      ProtobufCAllocator *allocator);
/* ProtoColor methods */
void   proto_color__init
                     (ProtoColor         *message);
size_t proto_color__get_packed_size
                     (const ProtoColor   *message);
size_t proto_color__pack
                     (const ProtoColor   *message,
                      uint8_t             *out);
size_t proto_color__pack_to_buffer
                     (const ProtoColor   *message,
                      ProtobufCBuffer     *buffer);
ProtoColor *
       proto_color__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto_color__free_unpacked
                     (ProtoColor *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*ProtoDuration_Closure)
                 (const ProtoDuration *message,
                  void *closure_data);
typedef void (*ProtoTimestamp_Closure)
                 (const ProtoTimestamp *message,
                  void *closure_data);
typedef void (*ProtoInterval_Closure)
                 (const ProtoInterval *message,
                  void *closure_data);
typedef void (*ProtoDate_Closure)
                 (const ProtoDate *message,
                  void *closure_data);
typedef void (*ProtoTimeOfDay_Closure)
                 (const ProtoTimeOfDay *message,
                  void *closure_data);
typedef void (*ProtoFieldMask_Closure)
                 (const ProtoFieldMask *message,
                  void *closure_data);
typedef void (*ProtoPostalAddress_Closure)
                 (const ProtoPostalAddress *message,
                  void *closure_data);
typedef void (*ProtoMoney_Closure)
                 (const ProtoMoney *message,
                  void *closure_data);
typedef void (*ProtoLatLng_Closure)
                 (const ProtoLatLng *message,
                  void *closure_data);
typedef void (*ProtoColor_Closure)
                 (const ProtoColor *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    month__descriptor;
extern const ProtobufCEnumDescriptor    day_of_week__descriptor;
extern const ProtobufCMessageDescriptor proto_duration__descriptor;
extern const ProtobufCMessageDescriptor proto_timestamp__descriptor;
extern const ProtobufCMessageDescriptor proto_interval__descriptor;
extern const ProtobufCMessageDescriptor proto_date__descriptor;
extern const ProtobufCMessageDescriptor proto_time_of_day__descriptor;
extern const ProtobufCMessageDescriptor proto_field_mask__descriptor;
extern const ProtobufCMessageDescriptor proto_postal_address__descriptor;
extern const ProtobufCMessageDescriptor proto_money__descriptor;
extern const ProtobufCMessageDescriptor proto_lat_lng__descriptor;
extern const ProtobufCMessageDescriptor proto_color__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_parse_5fproto_5fgoogle_5ftypes_2eproto__INCLUDED */
