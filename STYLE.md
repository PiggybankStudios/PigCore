# Coding Style Guidelines/Rules
1. All truthy defines should have a value of 0 or 1, not true or false, and not an empty definition. Thus we use `#if DEFINE` rather than stuff like `#ifdef DEFINE` for most of our preprocessor checks that we control. Checking if a macro is defined is allowed but not the primary way we do this logic
2. In Batch scripts we use `::` syntax for comments, not `REM`, except when inside an if/else scope where `::` does not work. Environment variables internal to a script will use `%lowercase_syntax%`
3. Keywords NOTE: and TODO: should be used with the expectation that they will be highlighted by the editor in any file they appear
4. All compilable units (.exe, .dll, .lib) shall adopt a "unity build" approach where a single main.c can be compiled and it will `#include` all other source code it needs from there
5. We shall adhere to warning level 4 on MSVC compiler except for a designated set of warnings we don't care about, specified in build.bat. All warnings will be treated as errors and therefore must be fixed before checkin
6. All source files should have a header that clearly states the name of the file, creation date, author, and optionally a description of what the file contains. Script files like .bat and .py are excluded from this requirement.
7. All source files and folders containing them should be strictly lowercase with no spaces to make multi-platform path handling in build scripts and preprocessor easier
8. `ixx` and `uxx` types will be used in the most core layers of the hierarchy so we can support building things for 32-bit platforms like Playdate and WebAssembly, but these can be assumed to be 64-bit types in the upper layers that are not planned to be used outside the desktop computing environment. `rxx` may be used in certain scenarios where it makes sense to use doubles only if on a 64-bit target but generally using `r32` for most scenarios and only `r64` when truly needed (regardless of perf) is the appropriate approach for floating point types.
9. We use the shortened words Pntr (for pointer) Ex (for extended) Iter (for iterator) Str (for string) Nt (for null-terminated), Def (for definition). Type suffixes may also be used for function names where overloads would be used in C++ (or where having the type be clear is important, like math incidental functions from stdlib), for example R32, I32, I8, etc. Ex will often denote what would be an overloaded function in C++, where the Ex suffixed version is the "real" version that takes all the possible arguments, and the non-Ex-suffixed version(s) have fewer arguments, with the value for optional arguments being implied either by their name, or by the "common" default value for those arguments. Typically this means the Ex version is called much less often, since the arguments that have "common" default values would imply that calls to the Ex version to specify a different value are the minority.
10. All header files will include all the dependencies they rely upon explicitly, rather than implicitly relying on a required header for one of it's requirements. Unless the file actually uses nothing from the secondary include directly, then it can omit the include in the hopes that if the thing it actually depends upon eventually removes that dependency the file won't have an unnecassary include for something it really doesn't need. Any compilable .c file must include all it's dependencies, other .c files generally do not, they are generally ordered by some parent .c file that explicitly states the order of compilation. Some header files may wrap a collection of other header files to make it easy to include a whole bunch of header files. These can be included instead of the entire list of dependencies, but for core files that may be reused in various contexts this is discouraged. This is mostly for compilation unit authors that don't care too much about minimizing dependencies and just want to bring in a whole swath of functionality easily.
11. File names are generally prefixed with the name of the folder they reside in. This may seem a little redundant but it makes it easier to talk about and search for them in a unique way. The folder name prefix can be used as part of it's logical name for the file. For example, the `mem_arena.h` file in the `mem` folder does not need to be called `mem_mem_arena.h` for it to be properly named after "Memory Arena".
12. Structures, enumerations, unions, and complex typedefs should adopt the `UppercaseFirstLetter` naming pattern. Enumeration values should have the same name as their enumeration type as a prefix with an underscore followed by the name for each value. If an enumeration uses the last value as a count it should have the suffix `_Count`. If the enumeration has an invalid value it should be the first one, it should have a value of 0, and it should have the suffix `_None`. Function typedefs should have the `_f` suffix to clearly distinguish them as a typedef, not a function name.
13. Macros that accept a type as one of their parameters should have the type FIRST in the parameter list to mimic the way template functions look
14. Multi-statement function-like macros should always have a `do { ... } while(0)` wrapper around them to ensure that if they are used in a single-line if-statement or loop that their subsequent instructions don't accidentally "leak" out of the loop. These curly brackets also provide a normal-ish looking structure to the lines following the `#define`, as-if the macro actually is a function. This requires that we use backslashes at the end of every line which can be a bit ugly but setting up an editor macro to insert and strip these backslashes at a specific column is very easy and removes that downside
15. Functions that want to have optional arguments can generally be served by function-like macros with a few different names that map down to one function. The actual function may opt to have a `_` suffix to indicate it isn't normally supposed to be called directly, allowing one of the macros to adopt the normal name for that function without the `_` suffix. See `VarArrayAdd_`, `VarArrayAdd`, `VarArrayAddHard`, etc.
16. When using `#if` or `#ifdef` blocks where one or more of the sections of code are longer than a few (say 5) lines we add a comment after the `#else` block that describes what that section is gated behind. `#endif` blocks receive a comment that mirrors the `#if` condition. For example `#if SOME_DEFINE ... #else //!SOME_DEFINE ... #endif //SOME_DEFINE`. This is helpful for `#if` blocks that span entire files, and especially if multiple blocks all end in the same location. Also helpful for searching the file for the matching `#endif` for an `#if`
17. Preprocessor directives are allowed to be indented with whitespace (unlike some codebases that adhere to earlier C standards that require them to be on column 0). Code inside a preprocessor `#if` directive does not **have** to be indented, but if it makes the readability better an indent can be added, even if the resulting C code after the preprocessor is weirdly indented. If the `#if` directive is inside a function and a bare `{ }` scope can be added to make the indentation have a cause then that is preferred.
18. All characters in string literals (and code files in general) should be strictly within the first 127 characters in the ASCII chart. Any character outside this range that might cause confusion with character encoding (i.e. anything that's not a 1-byte sequence when encoded in UTF-8) should be entered using the `\uXXXX` or `\UXXXXXXXX` escape sequences. This ensures that compiler support for code files with different character encodings is never an issue.

# Motivations
This section describes some of the fundamental motivations and goals I have while writing this code base that feed into our decision making for the Style Guidelines/Rules listed above. This are listed here in an effort to inform the reader "why" all of these guidelines/rules were chosen, and to help encourage them to be re-evaluated if the readers goals are substantially different than my goals while writing this codebase.

1. My primary focus is to make video games, while leaving the door open to make "tools" (non-game software products) using a large portion of what would typically be classified as a "game engine". These tools therefore may not have the "best" or "industry standard" backbone since their technlogy foundation was largely focused on game development but this also means that can take advantage of "gamey" UX patterns (like animated transitions or particle effects) that may have no further purpose than to make the tool a little more "fun" for the user.
2. The aim is to make a single repository with the majority of the "re-usable" code that I personally can share between projects that I work on. So although various portions of the codebase may be named or styled like they are a "game engine" in the traditional sense, they will first and foremost be targeted at accelerating my personal workflows and preferences, rather than trying to be the most reusable or general purpose code. Put another way, the ability for someone besides me to use this codebase is strictly **secondary** to my own ability to use the codebase. I am allowed to make assumptions and trade-offs specifically to benefit my own programming patterns and projects.
3. I want to keep this codebase "simple" (aka as few pieces, as few lines, or as little overhead as possible) wherever I can. However, this codebase will also allow experimental or new patterns that are not yet proven to be worth the complexity for some amount of time, until they either can be proven useful, or not useful enough. Or until a better pattern is discovered to replace that pattern. This feeds the support for making many of the pieces of the repository optional (i.e. you can include `mem_arena.h` but NOT include `std_basic_math.h`) because it allows the more well-trod proven parts to live alongside the experimental parts without hampering the usability, portability, etc. of the well-trod parts that may be depended upon by projects that do not want or need the experimental parts.
4. I started writing this codebase with a decent amount of prior knowledge building games, game engines, tools, and other software in C-like C++ (and also C++ where I am required, e.g. at work) so a lot of the decisions will be informed by what has worked for previous projects. My knowledge of C is deeper than C++, but I also have been compiling most of my "C" code using C++ compilers, so my knowledge of the distinction between the two might be lacking in specific areas. So although I consider myself primarily to be a C programmer, I may have weird expectations stemming from my long usage of C++ compilers.
5. My primary goal is to actually make real products (games, tools, etc.) that people can benefit from, so the codebase does not have to be perfect or fully featured, it simply needs to be good enough to be able to make various kinds of products reliably and of good quality. The "completeness" of any particular area of this codebase will be primarily driven by my time spent trying to make end-products, rather than by explicit research or feedback on what people generally want in that space. As an example, our font layout/rendering code will very likely never have full Unicode support because none of the projects I am planning on working on need full support for all characters and logic put forth by the Unicode standard. Building out support for more "fully featured" pieces is useful sometimes even when they aren't directly needed by a particular project, but this can quickly become a time sink and it's hard to make proper decisions about how code should be structured when there isn't a real life use case to inform the decisions. So adding features or completing areas of the codebase is slightly discouraged unless real prior use cases are known or upcoming use cases are close enough be reasoned about.
6. It is explicitly NOT the goal for this repository to be something that anyone besides me can clone and use "out of the box." This project is open source and people can use it "as is" if it fits their purpose but I am not designing this repository around the assumption that people will use it directly. Rather I want the project to be a good example of one way someone might organize their code, how they might solve particular problems, and how various decisions have and will affect various software built on top.
7. This project marks the beginning of my own journey trying to be more aware of my usage of specific language features and how they are standardized and supported by various compilers. The codebase isn't meant to be an example of what is possible with the latest C language specification (i.e. C23) since doing so would require us to limit ourselves to particular compilers that support all (or as much as possible) of this newer language specification. Instead the goal is to be open to using these features where they are obviously helpful and only once we've done some "spot checking" to see which compilers support the feature. If we find that a particular feature is not supported by a compiler (or a version of a compiler) that we want to use for a particular project then the feature will likely be guarded behind preprocessor macros to make it easy to remove them from the codebase in those projects. However, we do not need to support earlier versions of the C language specification for the sake of "portability" in the abstract. Portability is only a concern insomuch as it applies to the particular target platforms/compilers that I am actively using or plan to use.
8. Many decisions in the codebase are made under the assumption that a single person is using and maintaining the code. Many problems that arise when working as a team of engineers (esp. larger teams, like 10+ people) are not worth solving when a project is being done by a single engineer. The code in this repository is not necassarily designed to be used by larger teams because often designing code to be used by a larger team is both more work and worse when it is used by single person. This includes concerns related to source control limitations and expectations. The codebase is developed using a single branch in git with a single person making changes so there are rarely any scenarios where merging is required. So the code does not need to be split into files based on fractured "ownership" of the systems between multiple engineers. The folder/file structure is almost entirely designed to describe the purpose of that code, not to act like barriers for asynchronous collaboration between engineers. The only collaboration that is factored into structure is between my past, present, and future self. These versions of myself in time do collaborate in a way that has some analogous relation to inter-personal collaboration but the similarity is small.