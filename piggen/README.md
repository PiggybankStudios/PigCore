# piggen Folder
The piggen folder contains a `main.c` that can be compiled into `piggen.exe` which does the job of generating C code from custom syntax embedded inside .h/.c files. The generated files are placed in a `gen` folder next to where piggen was run from (usually inside the `_build` folder) and then the original source file is modified (if needed) to #include the generated file.

# Piggen Design Notes
Solutions for generating code come in many forms. After considering the kinds of problems I want to solve, I have decided on a particular form factor and intended use cases for piggen that might seem a little peculiar so I'd like to list the decisions that were made and the reasoning behind them to hopefully make it more clear:

1. Piggen recursively searches a folder structure for C/C++ source files, identifying them by their extension. It has no idea what the dependencies are between these files, how or if they are going to get compiled, or what other files will be compiled/linked with it. This design is chosen because parsing the preprocessor and/or C syntax is a rather large and complex task and is very error prone. Most of the time we don't need to really know about the compilation units or dependencies or #defines in order to correctly implement the code generation we want to do. A majority of the code generation we do is local to each PIGGEN snippet. For the codegen that seems to depend on compilation unit relationships, there are a few tricks I can use to skirt around the need that are acceptable to me.
2. The location of the generated code is important, especially since we use a "unity build" style build system (everything is compiled using a single .c file). This means we want to insert generated code into a file, directly in the context where the snippet is written. Instead of inserting the generated code directly, we place the code in a header file and #include it. Piggen will modify source files to ensure the correct #include line exists (since it decides on the name of the generated file) and is up to date. Otherwise, Piggen will avoid modifying source files, meaning that most of the time the source files will not change when Piggen is run.
3. Generated file names are very similar to the original file they came from, but since we can have multiple PIGGEN snippets in a file, we give them an extra index suffix to make sure they are unique while not having them change very often (they only change when snippets are added or removed from the file, or the file name changes). This does not handle if two files have the same name but live in different folders, since our repository generally does not have that problem. The file name decision could be easily modified to make it include the entire file path, or some relative portion of the path
4. Piggen places all generated files into a single folder (decided by the `-o="path"` option). Generally this is in `_build/gen` but it can be changed per-project depending on the needs. The intent is that the generated code is not checked into the source code repository, so only changes to the PIGGEN snippets are seen as really changes in the commits.
5. The recursive walk can be limited by any number of exclude strings which will prevent the walk from entering any folder or opening any file path that starts with the string. This allows us the convenience of automatically discovering new folders/files that are created while not walking folders/files that are not intended to be seen by Piggen.
6. Some of the more complex logic for generating code is written directly into the C code that makes up piggen.exe. Rather than designing every feature in Piggen to be re-usable and abstract, I allow some bits of logic to be written and used for a particular use case. Generally I prefer finding re-usable and generic solutions if possible so that multiple projects can benefit from a particular pattern of code generation, but I am allowed to change and extend Piggen when that's not possible.
